<!doctype html>
<html lang = "en" >
<head>

<meta charset = "utf-8" >
<meta name="viewport" content = "width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0" >
<meta name=description content="Identify non-watertight surfaces. Highlight errant faces with red borders" >
<meta name=keywords content="Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM" >
<meta name="date" content = "2019-12-13" >
<meta name = "version" content = "0.00.00" >

<title>Manifold 0.04.02</title>

<link href="src/style.css" rel="stylesheet" >

</head>

<body>

	<script src = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/build/three.min.js" ></script>
	<script src = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/controls/TrackballControls.js" ></script>

	<script src="src/gto-generate-threejs-objects-02.js" ></script>

	<button id="expandButton" onclick="toggleNavMenu();" >☰</button>

	<nav id="navMenu" >

		<header id="hdrTitle" ></header>

		<p>
			<button onclick=controls.reset(); title="Return to default view">reset view</button>

			<button onclick=zoomObjectBoundingSphere(); title="zoom without shifting camera angle" >zoom all</button>
		</p>

		<div id=GTOdivMenuGenerateThreejsObjects ></div>

		<p>
			<button onclick=addHole(2) >add hole with first vertex in mesh</button>
		</p>
		<p>
			<button onclick=addHole() >add hole with random vertex</button>
		</p>

		<div id=divMessageHoles ></div>

		<p>
			<button onclick=checkEdges(mesh) >check edges </button>
		</p>


		<div id=divStatsEdges ></div>

		<div id=divMessageEdges > </div>

		<footer>

			<hr>

			<center title="hello! click me to go up to the top"><a href=javascript:navMenu.scrollTo(0,0); > ❦ </a></center>

		</footer>

	</nav>

	<main id=main >

		<div id="divContent" ></div>

	</main>


<script>


THREE.Vector3.prototype.equals = function(v, tolerance =  0.00001) {

	return (
		Math.abs(v.x - this.x) < tolerance &&
		Math.abs(v.y - this.y) < tolerance &&
		Math.abs(v.z - this.z) < tolerance
	);

};



const urlSourceCode = "https://github.com/ladybug-tools/spider/tree/master/cookbook/manifold";
const urlSourceCodeIcon = "src/github-mark-32.png";

let mesh, material, geometry, edges, boxHelper;
let axesHelper;
let renderer, camera, controls, scene;
let sceneRotation = 1;
let eventResetAll;

init();
animate();

function init() {

	hdrTitle.innerHTML = getTitle();

	GTOdivMenuGenerateThreejsObjects.innerHTML = GTO.getMenu();

	renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( - 100, - 100, 100 );
	camera.up.set( 0, 0, 1 );

	controls = new THREE.TrackballControls( camera, renderer.domElement );
	controls.rotateSpeed = 4;

	scene = new THREE.Scene();

	window.addEventListener( "resize", onWindowResize, false );
	window.addEventListener( "orientationchange", onWindowResize, false );
	window.addEventListener( "keyup", () => sceneRotation = 0, false );
	renderer.domElement.addEventListener( "click", () => sceneRotation = 0, false );

	axesHelper = new THREE.AxesHelper( 100 );
	scene.add( axesHelper );

	geometry = new THREE.BoxBufferGeometry( 50, 50, 50 );
	material = new THREE.MeshNormalMaterial( { opacity: 0.85, side:2, transparent: true });
	mesh = new THREE.Mesh( geometry, material );
	scene.add( mesh );

	eventResetAll = new Event( "onresetall");

	window.addEventListener( "onresetall", resetHome );

	window.dispatchEvent(eventResetAll);

}


function resetHome() {

	divMessageHoles.innerHTML = divMessageEdges.innerHTML = divStatsEdges.innerHTML="";

	console.log( 'reset manifold' );

}


function addHole( index ) { // z- coordinate in first vertex

	const geometry = mesh.geometry

	if ( mesh.geometry.type.includes( "BufferGeometry" ) === false ) {

		alert( "Holes need to be made before the check. Load a fresh object and try again");
		return;

	}

	const pos = geometry.attributes.position.array;

	index = index === 2 ? index : Math.floor( pos.length * Math.random() );

	pos[ index ] = -88;

	geometry.attributes.position.needsUpdate = true;

	divMessageHoles.innerHTML +=`<div>hole: vertex ${ Math.floor( index / 3 )  }</div>`;

	// scene.children[ 1 ].geometry.vertices

}




function checkEdges() {

	edges = [];

	mesh.updateWorldMatrix();

	mesh.geometry = mesh.geometry.type.includes( "BufferGeometry" ) ?
		new THREE.Geometry().fromBufferGeometry(mesh.geometry) : mesh.geometry;

	timeStart = performance.now();

	mesh.geometry.faces.forEach(function (face, idx) {

		const lines = getEdges( face, idx );

		edges.push( ...lines );

	} );
	divStatsEdges.innerHTML = `<div>time edges: ${ ( performance.now() - timeStart ).toLocaleString() }</div>`;

	//console.log( 'edges', edges );

	edgePairs = [];

	timeStart = performance.now();

	for ( let i = 0; i < edges.length; i++ ) {

		const edge1 = edges[ i ];

		const edge1start = edge1.start;

		const edge1end = edge1.end;

		for ( let j = 0; j < edges.length; j++ ) {

			const edge2 = edges[ j ];

			if ( edge1start.equals( edge2.end ) && edge1end.equals( edge2.start ) ) {

				edgePairs.push( i );

			}

		}
	}
	divStatsEdges.innerHTML += `<div>time pairs: ${ ( performance.now() - timeStart ).toLocaleString() }</div>`;
	//console.log( 'edgePairs', edgePairs );

	edgeIndexNoPairs = [];

	for ( let i = 0; i < edges.length; i++ ) {

		if ( !edgePairs.includes( i ) ) {
			//console.log( 'edgeNoPairs', i, edges[  i ], edges[  i ].faceIndex );

			edgeIndexNoPairs.push( i );

		}

	}
	console.log( 'edgeIndexNoPairs', edgeIndexNoPairs );


	edgeIndexNoPairs.forEach( hole => {

		const face = mesh.geometry.faces[ edges[ hole ].faceIndex ];

		const vs = mesh.geometry.vertices;
		addLine( [ vs[ face.a ], vs[ face.b ], vs[ face.c ], vs[ face.a ] ] );

	} );


	identifyVertices( edgeIndexNoPairs );


	if ( edgeIndexNoPairs.length === 0 ) {

		divMessageEdges.innerHTML = `<p>Looks like this mesh is 'watertight'</p>`;

	} else {

		divMessageEdges.innerHTML = `<p>Faces with issues have a red border. ${ edgeIndexNoPairs.length } faces with issues</p>`;

	}

}



function getEdges( face, idx = 0 ) {

	let a = new THREE.Vector3();
	let b = new THREE.Vector3();
	let c = new THREE.Vector3();

	// mesh.localToWorld( a.copy( mesh.geometry.vertices[face.a] ));
	// mesh.localToWorld( b.copy( mesh.geometry.vertices[face.b] ));
	// mesh.localToWorld( c.copy( mesh.geometry.vertices[face.c] ));

	a.copy( mesh.geometry.vertices[face.a] )
	b.copy( mesh.geometry.vertices[face.b] )
	c.copy( mesh.geometry.vertices[face.c] );

	const lineAB = new THREE.Line3(a, b);
	const lineBC = new THREE.Line3(b, c);
	const lineCA = new THREE.Line3(c, a);

	lineAB.faceIndex = lineBC.faceIndex = lineCA.faceIndex = idx;

	return [ lineAB, lineBC, lineCA ];

}


function identifyVertices( edgeIndexNoPairs ) {

	verticesNoP = [];
	verticesIndex= [];
	index = 0;

	edgeIndexNoPairs.forEach( index => {

		line = edges[ index ]
		start = line.start;
		end = line.end;
		verticesNoP.push( start, end );
		verticesIndex.push( index++, index++ );

	});
	console.log( 'verticesNoP', verticesNoP );
	console.log( 'verticesIndex', verticesIndex );

//what to do when all duplicates? Look for triads?

	duplicates = [];
	duplicatesIndex = [];

	verticesMesh = mesh.geometry.vertices;

	for ( let i = 0; i < verticesNoP.length; i++ ) {

		vertexNoP = verticesNoP[ i ];

		let hits = 0

		for ( let j = 0; j < verticesMesh.length; j++ ) {

			vertex = verticesMesh[ j ];

			if ( vertex.equals( vertexNoP ) ) { hits++; }
		}

		console.log( 'hits', hits );

		if ( hits === 1 ) {

			const geometry = new THREE.BoxGeometry( 2, 2, 2 );
			const material = new THREE.MeshNormalMaterial( { opacity: 0.85, side:2, transparent: true });
			const telltale = new THREE.Mesh( geometry, material );
			telltale.position.copy( vertexNoP );
			//telltale.position.set( 0, 0, 58 );
			mesh.add( telltale );

		}

	}


	// vertices.forEach( ( vertex, index ) => {

	// 	if ( duplicates.indexOf( vertex ) === -1 ) {
	// 		duplicates.push( vertex );
	// 		duplicatesIndex.push( verticesIndex[ index ] ); }

	// } )
	// console.log( 'duplicates', duplicates );
	// console.log( 'duplicatesIndex', duplicatesIndex );

	// verticesErrantIndex = verticesIndex.filter( index => duplicatesIndex.indexOf( index ) === -1 );
	// console.log( 'verticesErrantIndex', verticesErrantIndex );

	// verticesErrant = verticesErrantIndex.map( index => vertices[ index ] );


	//try tell tales on all

	// verticesErrant.forEach( vertex => {


	// 	const geometry = new THREE.BoxGeometry( 2, 2, 2 );
	// 	const material = new THREE.MeshNormalMaterial( { opacity: 0.85, side:2, transparent: true });
	// 	telltale = new THREE.Mesh( geometry, material );
	// 	telltale.position.copy( vertex );
	// 	//telltale.position.set( 0, 0, 58 );
	// 	mesh.add( telltale );

	// 	console.log( '', telltale );


	// } )

}


function addLine( vertices ) {

	const geometry = new THREE.Geometry();
	geometry.vertices = vertices || [ v( -10, 0, 0 ),  v( 0, 10, -10 ), v( 10, 0, 0 ) ];
	const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
	const line = new THREE.Line( geometry, material );

	mesh.add( line );
	return line;

}




function zoomObjectBoundingSphere( obj = mesh ) {
	//console.log( "obj", obj );

	const bbox = new THREE.Box3().setFromObject( obj );
	//console.log( "bbox", bbox )

	if ( bbox.isEmpty() === true ) { return; }

	const sphere = bbox.getBoundingSphere( new THREE.Sphere() );
	center = sphere.center;
	radius = sphere.radius;

	controls.target.copy( center ); // needed because model may be far from origin
	controls.maxDistance = 5 * radius;

	camera.position.copy( center.clone().add( new THREE.Vector3( - 1.5 * radius, - 1.5 * radius, 1.5 * radius ) ) );
	camera.near = 0.001 * radius; //2 * camera.position.length();
	camera.far = 10 * radius; //2 * camera.position.length();
	camera.updateProjectionMatrix();

};


// menus

function toggleNavMenu() {

	expandButton.classList.toggle( "collapsed" );
	navMenu.classList.toggle( "collapsed" );
	main.classList.toggle( "collapsed" );

}


function getTitle() {

	document.title = document.title ? document.title : location.href.split( "/" ).pop().slice( 0, - 5 ).replace( /-/g, " " );
	const version = document.head.querySelector( "[ name=version ]" ).content;
	const description = document.head.querySelector( "[ name=description ]" ).content;

	const htm =
	`
		<h2>
			<a href=${ urlSourceCode } target=_top title="Source code on GitHub" >
				<img src="${ urlSourceCodeIcon }" alt="GitHub logo" height=18 style=opacity:0.5; >
			</a>
			<a href="" title="Click to reload this page" >${ document.title }</a>
		</h2>

		<p>
			${ document.head.querySelector( "[ name=description ]" ).content }
		</p>
	`;

	return htm;

}


// three.js

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

	controls.handleResize();

	//console.log( "onWindowResize  window.innerWidth", window.innerWidth );

}



function animate() {

	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update();
	scene.rotation.z += sceneRotation / 1000;

}


</script>
</body>
</html>