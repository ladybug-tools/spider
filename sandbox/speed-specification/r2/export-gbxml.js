/* Copyright 2017 Ladybug Tools authors. MIT License */

// the naming of things is very messy indeed

	var checkWindow;

	let textMenu;

	let campus;
	let building;

	let storeys;
	let zones;
	let spaces;
	let openingId = 1;
	let overhangId = 1
	let shadeId = 1;

	function initExportGbxml() {

		campus = {};

		campus.area = 5000;
		campus.areaUnit = 'SquareFeet';
		campus.buildingId = 1;
		campus.cadModelAzimuth = 0;
		campus.campusId = 'Facility';

		campus.daylightSavings = true;
		campus.description = 'Generated by Ladybug-Tools/Spider/Build Well';
		campus.elevation = 000000;

		campus.lengthUnit = 'Feet';
		campus.longitude = -122.398;
		campus.latitude = 37.796;
		campus.locationName = 'San Francisco CA United States';
		campus.length1 = 50;
		campus.name = 'Financial District Redevelopment Area';
		campus.opacity = 90;
		campus.orientation = 0;
		campus.overhangDepth = 0; // 1 + Math.floor( 1 * Math.random() );
		campus.perimeterDepth = 15;

//		campus.storeys = 1; // + Math.floor( 4 * Math.random() );
//		campus.storeyHeight = 10;
		campus.streetAddress = '440 Davis Court';
		campus.surfaceReferenceLocation = 'Centerline' ;

		campus.temperatureUnit = 'F';
		campus.useSIUnitsForResults = true;
		campus.version = '6.01';
		campus.verticalSeparation = 0;
		campus.volume = campus.area * theBuilding.storeys * theBuilding.storeyHeight;
		campus.volumeUnit = 'CubicMeters';

		campus.width1 = 10;
		campus.wwr = 40 + Math.floor( 40 * Math.random() );
		campus.zipcodeOrPostalCode = '94111';

		theBuilding.spaces = [];
		theBuilding.zones = [];
		theBuilding.name = 'theBuilding';

		buildings = getBuildings();

	}

	function getBuildings() {

		let buildings = [];

		for ( let child of scene.children ) {

			if ( child.name.includes( 'uilding' ) && child.visible === true ) {

				buildings.push( child );

			}

		}

		return buildings;

	}

	function getBuildingData() {

		if ( !theBuilding.mesh ) { alert( 'Please create a building first. '); return; };

		initExportGbxml();

//console.log( 'buildings', buildings );
//console.log( 'campus', campus );

		if ( window.checkWindow ) { window.checkWindow.close(); }

		textMenu = '';

		textMenu +=
//			'<?xml version="1.0" encoding="UTF-16"?>\n' +
			'<?xml version="1.0" encoding="UTF-8"?>\n' +
			'<gbXML xmlns="http://www.gbxml.org/schema" ' +
				'xmlns:xsd="http://www.w3.org/2001/XMLSchema" ' +
				'xsi:schemaLocation="http://www.gbxml.org/schema http://gbxml.org/schema/6-01/GreenBuildingXML_Ver6.01.xsd" ' +
				'xmlns:xhtml="http://www.w3.org/1999/xhtml" ' +

				'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
				'useSIUnitsForResults="' + campus.useSIUnitsForResults + '" ' +
				'SurfaceReferenceLocation="' + campus.surfaceReferenceLocation + '" ' +
				'temperatureUnit="' + campus.temperatureUnit + '" ' +
				'lengthUnit="' + campus.lengthUnit + '" ' +
				'areaUnit="' + campus.areaUnit + '" ' +
				'volumeUnit="' + campus.volumeUnit + '" ' +
				'version="' + campus.version + '"' +

			' >\n' +

			'\t<Campus id="' + campus.campusId + '" >\n' +

				'\t\t<DaylightSavings>' + campus.daylightSavings + '</DaylightSavings>\n' +
				'\t\t<Name>' + theBuilding.mesh.name + '</Name>\n' +

			'\t\t<Location>\n' +
				'\t\t\t<ZipcodeOrPostalCode>' + campus.zipcodeOrPostalCode + '</ZipcodeOrPostalCode>\n' +
				'\t\t\t<Longitude>' + campus.longitude + '</Longitude>\n' +
				'\t\t\t<Latitude>' + campus.latitude + '</Latitude>\n' +
				'\t\t\t<Elevation>' + campus.elevation + '</Elevation>\n' +
				'\t\t\t<CADModelAzimuth>' + campus.cadModelAzimuth + '</CADModelAzimuth>\n' +
				'\t\t\t<Name>' + theBuilding.mesh.name + '</Name>\n' +
			'\t\t</Location>\n' +

			'\t\t<Building id="' + campus.buildingId + '" buildingType="Office" >\n' +

				'\t\t\t<Area>' + campus.area + '</Area>\n' +
				'\t\t\t<Name>' + theBuilding.mesh.name + '</Name>\n' +
				'\t\t\t<Description>' + campus.description + '</Description>\n' +
				'\t\t\t<StreetAddress>' + campus.streetAddress + '</StreetAddress>\n' +
			'\t\t\t<Volume>' + campus.volume + '</Volume>\n' +
		'';


		textMenu += getBuildingStoreys( campus );

		textMenu += getSpacesAndZones( campus );

		textMenu += '\t\t</Building>\n';

		textMenu += getSurfaces( theBuilding );

		zonesText = getZones( campus );

		textMenu +=

			'\t</Campus>\n' +
			zonesText +
			'\t<DocumentHistory>\n' +
			'\t</DocumentHistory>\n' +
			'</gbXML>\n' +
		'';

		divExportContent.innerHTML =

			'gbXML data<br>' +
			( campus.areaCheck ? 'area check: ' + campus.areaCheck + '<br>' : '' ) +
			'<textarea id=buildingData rows=50 style=height:500px;tab-size:4;width:100%; >' +
			textMenu +
			'</textarea>'

		'';

	}



	function getBuildingStoreys( campus ) {

		let textBuildingStoreys = '';

		for ( var i = 0; i < theBuilding.storeys; i++ ) {

			const storey = i + 1;

			textBuildingStoreys +=
				'\t\t\t<BuildingStorey id="storey-' + storey + '" >\n' +
				'\t\t\t\t<Name>storey ' + storey + '</Name>\n' +
				'\t\t\t\t<Level>' + ( i * theBuilding.storeyHeight ) + '</Level>\n' +
				'\t\t\t</BuildingStorey>\n' +
			'';

		}

//console.log( 'textBuildingStoreys', textBuildingStoreys );

		return textBuildingStoreys;

	}



	function getSpacesAndZones( campus ) {
//console.log( 'campus', campus );

		let textSpace = '';
		const spaces = theBuilding.spaces;
		const zones = theBuilding.zones;
		let spaceId = 1;

//console.log( 'theBuilding.mesh.children', theBuilding.mesh );

		for ( var i = 0; i < theBuilding.mesh.children.length; i++ ) {

			const vertices = theBuilding.mesh.children[ i ].geometry.vertices;
			const spacesPerStorey = vertices.length / 5 - 1;
			let storey = i + 1;
			let pathInterior = [];
			theBuilding.areaCheck = 0;

			for ( var j = 0; j < spacesPerStorey; j++ ) {
//console.log( 'spacesPerStorey', spacesPerStorey );
				const vertex1 = vertices[ j * 5 ];
				pathInterior.push( vertex1 );

//				let geometry = new THREE.BoxGeometry( 10, 10, 10 );
//				let material = new THREE.MeshNormalMaterial();
//				const mesh = new THREE.Mesh( geometry, material );
//				mesh.position.copy( vertex1 );
//				scene.add( mesh );

				const vertex2 = vertices[ ( j + 1 ) * 5 ];

//				geometry = new THREE.BoxGeometry( 1, 1, 10 );
//				material = new THREE.MeshNormalMaterial();
//				mesh = new THREE.Mesh( geometry, material );
//				mesh.position.copy( vertex2 );
//				scene.add( mesh );

				const area = vertex1.distanceTo( vertex2 ) * theBuilding.perimeterDepth + theBuilding.perimeterDepth  * theBuilding.perimeterDepth ;
				const volume = area * theBuilding.storeyHeight;
				theBuilding.areaCheck += area;

				spaces.push( { name: 'Floor: ' + storey + ' Space: ' + spaceId, id: spaceId, description: 'externally-facing space',
					area: area, storey: storey, volume: volume, zone: spaceId } );

				theBuilding.zones.push( { name: 'Floor: ' + storey + ' Zone: ' + spaceId, description: 'a zone' } );

				spaceId ++;

			}

// interior area

//console.log( 'obj', campus.mesh.getObjectByName( 'InteriorFloor' ) );

//			const path = campus.mesh;
//console.log( 'path', pathInterior );

			const area = Math.abs( THREE.ShapeUtils.area( pathInterior ) );
			const volume = area * theBuilding.storeyHeight;
			theBuilding.areaCheck += area;

			spaces.push( { name: 'Floor: ' + storey + ' Space: ' + spaceId, id: spaceId, description: 'internal space',
				area: area, storey: storey, volume: volume, zone: spaceId } );

			theBuilding.zones.push( { name: 'Floor: ' + storey + ' Zone: ' + spaceId, description: 'a zone' } );

			spaceId ++;

		}

		console.log( 'areaCheck', theBuilding.areaCheck );

		for ( var j = 0; j < spaces.length; j++ ) {

			const space = spaces[ j ];

			textSpace +=
				'\t\t\t<Space ' +
					'id="space-' + space.id + '" ' +
					'buildingStoreyIdRef="storey-' + space.storey + '" ' +
					'zoneIdRef="zone-' + space.id + '" ' +
					'conditionType="HeatedAndCooled" >\n' +
				'\t\t\t\t<Name>' + space.name + '</Name>\n' +
				'\t\t\t\t<Description>' + space.description + '</Description>\n' +
				'\t\t\t\t<Area>' + Number( space.area.toFixed(4) ) + '</Area>\n' +
				'\t\t\t\t<Volume>' + Number( space.volume.toFixed(4) ) + '</Volume>\n' +
				'\t\t\t</Space>\n' +

			'';

		}

//console.log( 'spaces', spaces );

		return textSpace;

	}



	function getZones() {

		let textZones = '';

		for ( let i = 0; i < theBuilding.zones.length; i++ ) {

			const zone = theBuilding.zones[ i ];

			textZones +=
				'\t<Zone id="zone-' + ( i + 1 ) + '" >\n' +
				'\t\t<Name>' + zone.name + '</Name>\n' +
				'\t\t<Description>' + zone.description + '</Description>\n' +
				'\t</Zone>\n' +
			'';

		}

//console.log( 'textZones', textZones );

		return textZones;

	}



	function getSurfaces() {

		let textSurfaces = '';

		for ( let i = 0; i < buildings.length; i++ ) {

			aBuilding = buildings[ i ];
//console.log( 'aBuilding', aBuilding );

			if ( aBuilding.name !== 'theBuilding' ) {

				textSurfaces += getSurfacesAdjacentBuildings( aBuilding );

			} else {
//console.log( 'campus', campus );

				textSurfaces += getSurfacesTheBuilding( aBuilding );

			}

		}

		return textSurfaces;

	}



	function getSurfacesTheBuilding() {
//console.log( 'theBuilding', theBuilding.children[ 0 ] );

		const geo = new THREE.BoxBufferGeometry( 3, 1, 20 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		let textSurfacesBits = '';

		let storeys = theBuilding.storeys; //campus.storeys;
		let surfaceId = 1;
		let spaceId = 1; // zoneId === spaceId
		let quad;
		let firstStoreyId = 1; //campus.useSIUnitsForResults ? 0 : 1;

		for ( let i = 0; i < storeys; i++ ) {
//console.log( 'storeys', storeys, theBuilding.mesh  );

			const meshFloor = theBuilding.mesh.children[ i ];
			const vertices = meshFloor.geometry.vertices;
			const spacesPerStorey = vertices.length / 5 - 1;
			const path = [];

			for ( let j = 0; j < spacesPerStorey; j++ ) {

				const pt1 = j * 5 ;
				const pt2 = pt1 + 5;
				const firstSpaceId = i * spacesPerStorey;
				const interiorSpaceId = i * spacesPerStorey + spacesPerStorey;

				const vect = vertices[ pt2 ].clone().sub( vertices[ pt1 ].clone() ).normalize();
				const angle = 888; // r2d * Math.atan2( vect.y, vect.x );

//console.log( 'angle', angle );

//			const mesh = new THREE.Mesh( geo, material );
//			mesh.position.set( vertices[ pt1 ] );
//			scene.add( mesh );

				quad = {
					angle: angle,
					description: 'floor: ' + ( i + firstStoreyId ),
					mesh: meshFloor,
					name: 'floor-' + ( i + firstStoreyId ) + '-space-' + ( j + 1 ),
					type: ( i === 0 ? 'SlabOnGrade' : 'InteriorFloor' ),
					spaceId1: spaceId,
					spaceId2: ( i === 0 ? undefined : spaceId + spacesPerStorey ),
					surfaceId: surfaceId,
					vertices: [ vertices[ pt1 ], vertices[ pt1 + 1 ], vertices[ pt2 + 1 ], vertices[ pt2 ] ]
				};

				surfaceId ++;

				textSurfacesBits += getSingleSurface( quad );

				quad = {
					angle: angle,
					description: 'interior wall: ' + ( i + 1 ),
					mesh: meshFloor,
					name: 'interior-wall-floor-' + ( i + 1 ) + '-space-' + ( j + 1 ),
					type: 'InteriorWall',
					spaceId1: spaceId,
					spaceId2: ( spaceId === interiorSpaceId ? firstSpaceId : interiorSpaceId ),
					surfaceId: surfaceId,
//					vertices: [ vertices[ pt1 + 1 ], vertices[ pt1 + 2 ], vertices[ pt2 + 2 ], vertices[ pt2 + 1 ] ]
					vertices: [ vertices[ pt1 + 3 ], vertices[ pt1 + 4 ], vertices[ pt2 + 4 ], vertices[ pt2 + 3 ] ]

				};

				surfaceId ++;

				textSurfacesBits += getSingleSurface( quad );

				if ( i + 1 === storeys ) {

					quad = {
						angle: angle,
						description: 'roof: ' + ( i + 1 ),
						mesh: meshFloor,
						name: 'roof-floor-' + ( i + 1 ) + '-space-' + ( j + 1 ),
						type: 'Roof',
						spaceId1: spaceId,
						spaceId2: undefined,
						surfaceId: surfaceId,
						vertices: [ vertices[ pt1 + 2 ], vertices[ pt1 + 3 ], vertices[ pt2 + 3 ], vertices[ pt2 + 2 ] ]
					};

					surfaceId ++;

					textSurfacesBits += getSingleSurface( quad );

				}

				quad = {
					angle: angle,
					description: 'wall: ' + ( i + 1 ),
					mesh: meshFloor,
					name: 'exterior-wall-floor-' + ( i + 1 ) + '-space-' + ( j + 1 ),
					type: 'ExteriorWall',
					spaceId1: spaceId,
					spaceId2: undefined,
					surfaceId: surfaceId,
//					vertices: [ vertices[ pt1 + 3 ], vertices[ pt1 + 4 ], vertices[ pt2 + 4 ], vertices[ pt2 + 3 ] ]
					vertices: [ vertices[ pt1 + 1 ], vertices[ pt1 + 2 ], vertices[ pt2 + 2 ], vertices[ pt2 + 1 ] ]

				};
				surfaceId ++;

				textSurfacesBits += getSingleSurface( quad );

				quad = {
					angle: angle,
					description: 'diagonal-wall: ' + ( i + 1 ),
					mesh: meshFloor,
					name: 'diagonal-interior-wall-floor-' + ( i + 1 ) + '-space-' + ( j + 1 ),
					type: 'InteriorWall',
					spaceId1: spaceId,
					spaceId2: ( spaceId < spacesPerStorey ? spaceId + 1 : 1 ),
					surfaceId: surfaceId,
					vertices: [ vertices[ pt2 + 1 ], vertices[ pt2 ], vertices[ pt2 + 3 ], vertices[ pt2 + 2 ] ]
				};

				surfaceId ++;

				textSurfacesBits += getSingleSurface( quad );

				path.push( vertices[ pt1 + 3 ] );

//console.log( 'spaceId', spaceId );

				spaceId ++;

			}

			textSurfacesBits += getSurfacesOverhangs( meshFloor, path, surfaceId ++ );

			textSurfacesBits += getSurfacesSlabs( meshFloor, path, 'InteriorFloor', surfaceId ++, spaceId  );

			if ( i + 1 === storeys ) {

				textSurfacesBits += getSurfacesSlabs( meshFloor, path, 'Roof', surfaceId ++, spaceId++, theBuilding.storeyHeight );

			}

			spaceId ++;

		}

		return textSurfacesBits;

	}



	function getSingleSurface( quad ) {

//console.log( 'quad', quad );

		const geometry = new THREE.BoxBufferGeometry( 8, 5, 3 );
		const material = new THREE.MeshNormalMaterial( { side: 2 } );

		let verticesClone = [];

		textQuad = '';

		for ( let i = 0; i < quad.vertices.length; i++ ) {

			vertex = quad.vertices[ i ].clone();
			vertex.applyMatrix4( quad.mesh.matrixWorld );

			textQuad += getCartesianPointText( vertex );
			verticesClone.push( vertex );

//			const mesh = new THREE.Mesh( geometry, material );
//			mesh.position.add( vertex );
//			scene.add( mesh );

		}

	if( quad.type === 'ExteriorWall' ) {

			let vertex = quad.vertices[ 0 ].clone();
			vertex.applyMatrix4( quad.mesh.matrixWorld );
			const pt1 = vertex;


			vertex = quad.vertices[ 3 ].clone();
			vertex.applyMatrix4( quad.mesh.matrixWorld );
			const pt2 = vertex;

			const vect = pt1.clone().sub( pt2.clone() ).normalize();
			const angle = r2d * Math.atan2( vect.y, vect.x );

//console.log( 'angle', angle, pt1, pt2 );
			quad.angle = angle;

			const mesh = new THREE.Mesh( geometry, material );
			mesh.position.copy( pt1 );
			scene.add( mesh );
//console.log( 'mesh', mesh );

		}


		let textSingleSurfaces =

			'\t\t<Surface surfaceType="' + quad.type + '" id="surface-' + quad.surfaceId + '" >\n' +
				'\t\t\t<Name>' + quad.name + '</Name>\n' +

			'\t\t\t<RectangularGeometry>\n' +
			'\t\t\t\t<Azimuth>' + quad.angle + '</Azimuth>\n' +
			'\t\t\t</RectangularGeometry>\n' +

			'\t\t\t<CADOjectId>none</CADOjectId>\n' +
			'\t\t\t<AdjacentSpaceId spaceIdRef="space-' + quad.spaceId1  + '" />\n' +
			( quad.spaceId2 ? '\t\t\t<AdjacentSpaceId spaceIdRef="space-' + quad.spaceId2  + '" />\n' : '' ) +
			'\t\t\t<PlanarGeometry>\n' +
			'\t\t\t\t<PolyLoop>\n' +

			textQuad +

		'';


		textOpen = quad.type === 'ExteriorWall' ? getOpening( quad ) : '';

		textSingleSurfaces +=
			'\t\t\t\t</PolyLoop>\n' +
			'\t\t\t</PlanarGeometry>\n' +
				textOpen +
			'\t\t</Surface>\n' +
		'';

		return textSingleSurfaces

	}



	function getOpening( quad ) {

		let textOpening = '';

		const geometry = new THREE.BoxBufferGeometry( 5, 8, 5 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		textOpening +=
			'\t\t\t<Opening openingType="FixedWindow" id="opening-' + openingId + '" >\n' +
			'\t\t\t\t<PlanarGeometry>\n' +
			'\t\t\t\t\t<PolyLoop>\n' +
		'';

		openingId ++;

		wwr05 = 0.5 * theBuilding.wwr / 100;

		verts = [

			quad.vertices[ 0 ].clone().lerp( quad.vertices[ 2 ].clone(), 0.5 - wwr05 ),
			quad.vertices[ 1 ].clone().lerp( quad.vertices[ 3 ].clone(), 0.5 - wwr05 ),
			quad.vertices[ 0 ].clone().lerp( quad.vertices[ 2 ].clone(), 0.5 + wwr05 ),
			quad.vertices[ 1 ].clone().lerp( quad.vertices[ 3 ].clone(), 0.5 + wwr05 )

		]


		for ( let i = 0; i < verts.length; i++ ) {

			vertex = verts[ i ];
			vertex.applyMatrix4( quad.mesh.matrixWorld );
			textOpening += getCartesianPointText( vertex );

//			const mesh = new THREE.Mesh( geometry, material );
//			mesh.position.add( vertex );
//			scene.add( mesh );

		}

		textOpening +=
			'\t\t\t\t\t</PolyLoop>\n' +
			'\t\t\t\t</PlanarGeometry>\n' +
			'\t\t\t</Opening>\n' +
		'';

		return textOpening;

	}



	function getSurfacesSlabs( slab, path, type, surfaceId, spaceId, height = 0 ) {

//console.log( 'path', path );

		textInterior = '';

		const area = THREE.ShapeUtils.area( path );

//console.log( 'areaNow', area );
		shape = new THREE.Shape( path );
		geometry = new THREE.ShapeGeometry( shape );
		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, height ) );

		quad = {
			description: type + ': ',
			area: area,
			volume: area * theBuilding.storeyHeight,
			mesh: slab,
			name: 'slab-floor-' + slab.userData.storey,
			type: type,
			spaceId1: spaceId,
			spaceId2: undefined,
			surfaceId: surfaceId,
			vertices: geometry.vertices
		};

		textInterior += getSingleSurface( quad )

//		textInterior += getSingleSurface( floor, geometry.vertices, type, surfaceId )

//		material = new THREE.MeshNormalMaterial();
//		mesh = new THREE.Mesh( geometry, material );
//		slab.add( mesh );

		return textInterior;

	}



	function getSurfacesOverhangs( storey, path, surfaceId, spaceId1 ) {
//console.log( 'storey', storey );

		let textOver = '';
//		const geometry = new THREE.BoxBufferGeometry( 3, 2, 1 );
//		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

//		let overhangId = ( storey.userData.storey - 1 ) * path.length + 1;
		let id = 1;
		for ( let i = 0; i < storey.children.length; i++ ) {

			const overhang = storey.children[ i ];
			if ( overhang.name !== 'overhang' ) { continue; }

			textOver +=
				'\t\t<Surface surfaceType="Shade" id="shade-' + ( overhangId ++ ) + '" >\n' +
				'\t\t\t<Name>overhang-storey-' + storey.userData.storey +'-space-' + ( id++ )+ '</Name>\n' +
				'\t\t\t<PlanarGeometry>\n' +
				'\t\t\t\t<PolyLoop>\n' +
			'';

//console.log( 'overhang', overhang );
//console.log( 'geometry', overhang.geometry.attributes.position.array );

			const coordinates = overhang.geometry.attributes.position.array;

			const vertices = [

				v( coordinates[ 6 ], coordinates[ 7 ], coordinates[ 8 ] ),
				v( coordinates[ 9 ], coordinates[ 10 ], coordinates[ 11 ] ),
				v( coordinates[ 3 ], coordinates[ 4 ], coordinates[ 5 ] ),
				v( coordinates[ 0 ], coordinates[ 1 ], coordinates[ 2 ] ),

			];

			for ( let j = 0; j < 4; j++ ) {

				vertex = vertices[ j ];
				vertex.applyMatrix4( overhang.matrixWorld );
				textOver += getCartesianPointText( vertex );
/*
				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.copy( vertex );
				mesh.name = 'shade';
				scene.add( mesh );
*/
//console.log( 'vertex', mesh.position );

			}

//			const mesh = new THREE.Mesh( geometry, material );
//			mesh.position.set( verts[ 1 ] );
//			scene.add( mesh );


			textOver +=
				'\t\t\t\t</PolyLoop>\n' +
				'\t\t\t</PlanarGeometry>\n' +
				'\t\t</Surface>\n' +
			'';
		}

//console.log( 'textOver', textOver );

		return textOver;

	}




	function getSurfacesAdjacentBuildings( object ) {

		let textSurfaces = '';

//console.log( 'getSurfacesAdjacentBuildings', object );

		const bb = new THREE.Box3().setFromObject( object );
		const mi = bb.min;
		const mx = bb.max;
//console.log( 'bb mi mx', bb, mi, mx );

		const geometry = new THREE.BoxBufferGeometry( 5, 5, 5 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		const faces =  [
			[ v( mi.x, mi.y, mi.z ), v( mx.x, mi.y, mi.z ), v( mx.x, mi.y, mx.z ), v( mi.x, mi.y, mx.z ) ],
			[ v( mi.x, mx.y, mi.z ), v( mx.x, mx.y, mi.z ), v( mx.x, mx.y, mx.z ), v( mi.x, mx.y, mx.z ) ],
			[ v( mi.x, mi.y, mi.z ), v( mi.x, mx.y, mi.z ), v( mi.x, mx.y, mx.z ), v( mi.x, mi.y, mx.z ) ],
			[ v( mx.x, mi.y, mi.z ), v( mx.x, mx.y, mi.z ), v( mx.x, mx.y, mx.z ), v( mx.x, mi.y, mx.z ) ],
			[ v( mi.x, mi.y, mx.z ), v( mx.x, mi.y, mx.z ), v( mx.x, mx.y, mx.z ), v( mi.x, mx.y, mx.z ) ]
		];

		for ( let i = 0; i < faces.length; i++ ) {

			textSurfaces +=
				'\t\t<Surface surfaceType="Shade" id="shade-' + ( i + 1 ) + '" >\n' +
				'\t\t\t<Name>' + object.name +'</Name>\n' +
				'\t\t\t<PlanarGeometry>\n' +
				'\t\t\t\t<PolyLoop>\n' +
			'';

			face = faces[ i ];

//			const v1 = object.localToWorld ( face[ 0 ] );
//			const v2 = object.localToWorld ( face[ 1 ] );
//			const v3 = object.localToWorld ( face[ 2 ] );
//			const v4 = object.localToWorld ( face[ 3 ] );

			const v1 = face[ 0 ];
			const v2 = face[ 1 ];
			const v3 = face[ 2 ];
			const v4 = face[ 3 ] ;

//			const vertices = [ v2, v1, v3, v4 ];
			const vertices = [ v1, v2, v3, v4 ];

			for ( let k = 0; k < 4; k++ ) {

				const vertex = vertices[ k ];
				textSurfaces += getCartesianPointText( vertex );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.copy( vertex );
				scene.add( mesh );

			}

			textSurfaces +=
				'\t\t\t\t</PolyLoop>\n' +
				'\t\t\t</PlanarGeometry>\n' +
				'\t\t</Surface>\n' +
			'';

		}

		return textSurfaces;

	}



	function getCartesianPointText( vertex ) {

		const textSurfaces =

			'\t\t\t\t\t<CartesianPoint>\n' +

				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.x.toFixed(4) ) + '</Coordinate>\n' +
				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.y.toFixed(4) ) + '</Coordinate>\n' +
				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.z.toFixed(4) ) + '</Coordinate>\n' +

			'\t\t\t\t\t</CartesianPoint>\n' +

		'';

		return textSurfaces;

	}


/////////////////////



	function checkGbxmlData() {

		if ( !textMenu ){ alert( 'get building data first' ); return; }

		let lines = textMenu.split( '\n' );
		const n = '\n';

		let text =
			selObject.value + n + n +
			'line 0: ' + lines[ 1 ] + n + n +
		'';

		errors = 0;

		for ( var i = 0; i < lines.length; i++ ) {

			line = lines[ i ];

			if (

				line.search( 'NaN' ) > 0 ||
				line.search( 'undefine' ) > 0 ||
				( line.search( 'AdjacentSpaceId ' ) > 0 && line === lines[ i + 1 ] )

			) {

				text +=
					'line' + ( i - 3 ) + ' ' + lines[ i - 3 ] + n +
					'line' + ( i - 2 ) + ' ' + lines[ i - 2 ] + n +
					'line' + ( i - 1 ) + ' ' + lines[ i - 1 ] + n +
					'line' + i + ' ' + line + n +
					'line' + ( i + 1 ) + ' ' + lines[ i + 1 ] + n +
					'line' + ( i + 2 ) + ' ' + lines[ i + 2 ] + n +
					'***' + n +
				'';

				errors ++

			}

		}

		text += 'lines checked: ' + lines.length + ' - errors found:' + errors + n;

		checkWindow = window.open( '', '', 'left=400,width=800,height=400,top=200' );

		checkWindow.document.write( '<textarea style=width:100%;height:100%; >' + text + '</textarea>' );
		checkWindow.document.title = 'gbXML error check';

//console.log( '', checkWindow );

	}



////////////////////

	function saveFile() {

		let blob;

		blob = new Blob( [ buildingData.value ] );

		let a = document.body.appendChild( document.createElement( 'a' ) );
		a.href = window.URL.createObjectURL( blob );
		const fileName = theBuilding.shape.toLowerCase() + '-' + theBuilding.area + 'area-' + theBuilding.storeys + 'flr-' + theBuilding.orientation + 'deg' + '.xml';
		a.download = fileName;

		a.click();
//		delete a;
		a = null;

		if ( window.checkWindow !== undefined ) { window.checkWindow.close(); }

	}
