# Software Quality Metrics

* How to describe software
* How to compare software
* How to setup some standards that help open source software be recognized

## Standards

* https://pm.stackexchange.com/questions/20950/what-is-the-best-industry-standard-report-for-code-quality-control-and-measureme
* ISO or IEEE?? https://pdfs.semanticscholar.org/de1c/f09a52540b0cc500d712fa44fed3c13dcf3d.pdf
* http://profs.etsmtl.ca/claporte/english/enseignement/cmu_sqa/Notes/Normes/Software_Engineering_Standards_Int.pdf

## ISO 25010 Software Quality Model

* https://iso25000.com/index.php/en/iso-25000-standards/iso-25010
* https://www.iso.org/standard/35733.html
* https://www.iso.org/obp/ui/#iso:std:iso-iec:25010:ed-1:v1:en

About

* https://www.codacy.com/blog/iso-25010-software-quality-model/
* https://nocomplexity.com/overview-of-iso-25010/
* https://nocomplexity.com/category/quality-management/

## ISO/IEC_9126

* https://en.wikipedia.org/wiki/ISO/IEC_9126
* http://www.arisa.se/compendium/
* http://www.arisa.se/compendium/node6.html

## IEEE Standard for a Software Quality Metrics Methodology

* https://standards.ieee.org/standard/1061-1998.html
* https://ieeexplore.ieee.org/document/749159
* https://github.com/rick4470/IEEE-SRS-Tempate

## Boehm software quality tree


* https://www.google.com/search?rlz=1C1GCEA_enUS815US815&q=:+Boehm%E2%80%99s+software+quality+tree


## Software

* https://en.wikipedia.org/wiki/Software_quality
* https://en.wikipedia.org/wiki/Software
* https://en.wikipedia.org/wiki/Application_software
* https://en.wikipedia.org/wiki/Software_development
* https://en.wikipedia.org/wiki/Software_design ***
* https://en.wikipedia.org/wiki/Open-source_software
* https://en.wikipedia.org/wiki/Open-source_software
* https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar


WBS

* https://en.wikipedia.org/wiki/Work_breakdown_structure
* https://www.lucidchart.com/blog/how-to-create-a-work-breakdown-structure-and-why-you-should

As you make a work breakdown structure, use the following rules for best results:

The 100% rule. The work represented by your WBS must include 100% of the work necessary to complete the overarching goal without including any extraneous or unrelated work. Also,  child tasks on any level must account for all of the work necessary to complete the parent task.

Mutually exclusive. Do not include a sub-task twice or account for any amount of work twice. Doing so would violate the 100% rule and will result in miscalculations as you try to determine the resources necessary to complete a project.

Outcomes, not actions. Remember to focus on deliverables and outcomes rather than actions. For example, if you were building a bike, a deliverable might be “the braking system” while actions would include “calibrate the brake pads.”

The 8/80 rule. There are several ways to decide when a work package is small enough without being too small. This rule is one of the most common suggestions—a work package should take no less than eight hours of effort, but no more than 80. Other rules suggest no more than ten days (which is the same as 80 hours if you work full time) or no more than a standard reporting period. In other words, if you report on your work every month, a work package should take no more than a month to complete. When in doubt, apply the “if it makes sense” rule and use your best judgment.

Three levels. Generally speaking, a WBS should include about three levels of detail. Some branches of the WBS will be more subdivided than others, but if most branches have about three levels, the scope of your project and the level of detail in your WBS are about right.
Make assignments. Every work package should be assigned to a specific team or individual. If you have made your WBS well, there will be no work overlap so responsibilities will be clear.



https://en.wikipedia.org/wiki/Software_design

Design considerations
There are many aspects to consider in the design of a piece of software. The importance of each consideration should reflect the goals and expectations that the software is being created to meet. Some of these aspects are:

* Compatibility - The software is able to operate with other products that are designed for interoperability with another product. For example, a piece of software may be backward-compatible with an older version of itself.
* Extensibility - New capabilities can be added to the software without major changes to the underlying architecture.
* Modularity - the resulting software comprises well defined, independent components which leads to better maintainability. The components could be then implemented and tested in isolation before being integrated to form a desired software system. This allows division of work in a software development project.
* Fault-tolerance - The software is resistant to and able to recover from component failure.
* Maintainability - A measure of how easily bug fixes or functional modifications can be accomplished. High maintainability can be the product of modularity and extensibility.
* Reliability (Software durability) - The software is able to perform a required function under stated conditions for a specified period of time.
* Reusability - The ability to use some or all of the aspects of the preexisting software in other projects with little to no modification.
* Robustness - The software is able to operate under stress or tolerate unpredictable or invalid input. For example, it can be designed with resilience to low memory conditions.
* Security - The software is able to withstand and resist hostile acts and influences.
* Usability - The software user interface must be usable for its target user/audience. Default values for the parameters must be chosen so that they are a good choice for the majority of the users.[6]
* Performance - The software performs its tasks within a time-frame that is acceptable for the user, and does not require too much memory.
* Portability - The software should be usable across a number of different conditions and environments.
* Scalability - The software adapts well to increasing data or number of users.